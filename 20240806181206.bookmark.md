# Subinterpreters for Python [LWN.net] (lwn.net)

<https://lwn.net/Articles/820424/>

## Source

```html
<!DOCTYPE html>
<html lang="en"><head><title>Subinterpreters for Python [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="robots" content="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png" type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/820424/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript" async="" src="https://e-4669.adzerk.net/ados?t=1722939130184&amp;request=%7B%22Placements%22%3A%5B%7B%22A%22%3A4669%2C%22S%22%3A20979%2C%22D%22%3A%22azk13321_leaderboard%22%2C%22AT%22%3A4%2C%22Z%22%3A%5B16026%5D%7D%2C%7B%22A%22%3A4669%2C%22S%22%3A20979%2C%22D%22%3A%22azk93271_right_zone%22%2C%22ATA%22%3A%5B5%2C10%2C6%5D%2C%22Z%22%3A%5B16027%5D%7D%2C%7B%22A%22%3A4669%2C%22S%22%3A20979%2C%22D%22%3A%22azk31017_tracking%22%2C%22AT%22%3A20%2C%22Z%22%3A%5B20995%5D%7D%5D%2C%22Keywords%22%3A%22T%253ASSL%22%2C%22Referrer%22%3A%22%22%2C%22IsAsync%22%3Atrue%7D"></script><script type="text/javascript" async="" src="https://engine.adzerk.net/ados.js"></script><script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo" border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo" border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/819797/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset" style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform" class="loginform">
        <label><b>User:</b> <input type="text" name="Username" value="" size="8" id="uc"></label> 
		<label><b>Password:</b> <input type="password" name="Password" size="8" id="pc"></label> <input type="hidden" name="target" value="/Articles/820424/"> <input type="submit" name="submit" value="Log in"></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe">
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register">
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Subinterpreters for Python</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</p></blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>May 13, 2020
           </div>
<p>
A project that has been floating around in the Python world for a number of
years is now working its way toward inclusion into the language—or not.
"Subinterpreters", which are separate Python interpreters that can
currently be created via the C API for extensions, are seen by some as a
way to get a more Go-like concurrency model for Python.  The first step
toward that goal is to expose that API in the standard library.  But there
are questions about whether subinterpreters are actually a desirable
feature for Python at all, as well as whether the hoped-for concurrency
improvements will materialize.
</p>

<h4>PEP 554</h4>

<p>
 Eric Snow's <a href="https://www.python.org/dev/peps/pep-0554/">PEP 554</a>
("<q>Multiple Interpreters in the Stdlib</q>") would expose the
existing 
subinterpreter support from the C API in the standard library.   That would
allow Python programs to use multiple separate interpreters; the PEP also
proposes to add a way to share some data types between the instances.   The
eventual goal is to allow those subinterpreters to run in parallel, but the
implementation is not there yet.
</p>

<p>
In particular, giving each subinterpreter
its own <a href="https://wiki.python.org/moin/GlobalInterpreterLock">global
interpreter lock</a> (GIL) is not (yet) on the table.  The GIL
prevents multiple threads from executing Python bytecode at the same
time.  It exists mainly because the CPython memory-management code and garbage
collector are not thread-safe.  But the existence of the GIL has meant that
other features, C-based extensions for example, depend on it for proper
functioning.  There have been efforts to remove the GIL from Python along
the way, including <a href="/Articles/754577/">the Gilectomy project</a>.
<a href="/Articles/754162/">Subinterpreters</a> are seen by some as another way of
addressing the "GIL problem". 
</p>

<p>
The PEP proposes adding an <tt>interpreters</tt> module to the standard
library that will allow the creation of subinterpreters as follows:
</p><pre>    interp = interpreters.create()
</pre>
Interpreters can then run code passed as a string to the <tt>run()</tt>
method.  Data is not shared between these interpreters unless it is done
explicitly by using "channels" created this way:
<pre>    recv, send = interpreters.create_channel()
</pre>
As might be guessed, simple objects (e.g. bytes, strings, integers) can then be
sent and received using the <tt>send()</tt> and <tt>recv()</tt> methods of
the corresponding channel objects.
<p></p>

<p>
The <tt>run()</tt> method blocks until the subinterpreter completes, though it can
be executed in a separate thread as an example from the PEP that uses the <a href="https://docs.python.org/3/library/threading.html"><tt>threading</tt></a>
module shows:
</p><div class="BigQuote">
<pre>interp = interpreters.create()
def run():
    interp.run('print("during")')
t = threading.Thread(target=run)
print('before')
t.start()
print('after')
</pre>
</div>
<p></p>

<p>
Because the GIL is shared between all of the interpreters, however, the
concurrency gains are minimal.  In the most recent revisions, the PEP tries to make it clear that
exposing the feature from the C API is worth doing regardless of what
happens with the GIL:
</p><div class="BigQuote">
To avoid any confusion up front: This PEP is unrelated to any efforts to
stop sharing the GIL between subinterpreters. At most this proposal will
allow users to take advantage of any results of work on the GIL. The
position here is that exposing subinterpreters to Python code is worth
doing, even if they still share the GIL.
</div>
<p></p>

<p>
PEP 554 has been around since 2017, but Snow thinks it is getting ready for
"pronouncement" (a decision to accept or reject it) now.  While he believes
there is value to exposing the interface in its own right, the PEP has had
trouble separating itself from the ongoing GIL work;
PEP 554 could perhaps
be added to Python&nbsp;3.9, though the GIL
changes are not complete.
In mid-April, Snow <a href="/ml/python-dev/CALFfu7DAg6Ka-=YA=LqAHf1zKzYNaF3pzVjnSLnmb=43Vp95UQ@mail.gmail.com/">posed</a>
a question to the python-dev mailing list, wondering if it made sense to hold off on the PEP
until 3.10 because there is no per-interpreter GIL.
</p><div class="BigQuote">
Many folks have conflated PEP 554 with having a per-interpreter GIL.
In fact, I was careful to avoid any mention of parallelism or the GIL
in the PEP.  Nonetheless some are expecting that when PEP 554 lands we
will reach multi-core nirvana.
<p>
While PEP 554 might be accepted and the implementation ready in time
for 3.9, the separate effort toward a per-interpreter GIL is unlikely
to be sufficiently done in time.  That will likely happen in the next
couple months (for 3.10).
</p><p>
So...would it be sufficiently problematic for users if we land PEP 554
in 3.9 without per-interpreter GIL?
</p></div>
<p></p>

<p>
His main concern is that users will be confused and frustrated by encountering
subinterpreters with a shared GIL, which will have lots of
limitations; that might lead them to not reconsider the feature when those
limitations are lifted for&nbsp;3.10.  He listed four options for
proceeding: merging it without the GIL changes, the same but mark it as a
"provisional" module, not merging until the GIL changes are ready, and the
same but adding a 3.9-only subinterpreters module to the <a href="https://pypi.org/">Python
Package Index</a> (PyPI).  He was in favor of the first or the second option.
</p>

<h4>C extensions</h4>

<p>
But others are concerned that adding subinterpreter support to the standard
library will put additional burdens onto the developers of C-based
extensions.  Those extensions sometimes use global variables, which do not
play well with subinterpreters—whether they are created via the existing C API or the proposed
standard library <tt>interpreters</tt> module.  That means that using
subinterpreters could lead to strange, hard-to-find problems when combined
with extensions.
</p>

<p>
CPython core developer Nathaniel Smith, who is also a core developer of the
C-based extension <a href="https://numpy.org/">NumPy</a>, was <a href="/ml/python-dev/CAPJVwBkWu1F7vgUveLh2Esg67d-ZSTPq-pPwLDYP5NHUVH7k8Q@mail.gmail.com/">particularly
unhappy</a> with the proposal:
</p><div class="BigQuote">
I think you've been downplaying the impact of subinterpreter support
on the existing extension ecosystem. All features have a cost, which
is why PEPs always require substantial rationales and undergo intense
scrutiny. But subinterpreters are especially expensive. Most features
only affect a small group of modules (e.g. async/await affected
twisted and tornado, but 99% of existing libraries didn't care); OTOH
subinterpreters require updates to every C extension module. And if we
start telling users that subinterpreters are a supported way to run
arbitrary Python code, then we've effectively limited extension
authors options to "update to support subinterpreters" or "explain to
users why they aren't writing a proper Python module", which is an
intense amount of pressure; for most features maintainers have the
option of saying "well, that isn't relevant to me", but with
subinterpreter support that option's been removed.
</div>
<p></p>

<p>
NumPy core developer  Sebastian Berg <a href="/ml/python-dev/bfdcaf1042ac644bd3f6f50c9453a5af00db75d4.camel@sipsolutions.net/">chimed
in</a> as well.  He suggested that it could take up to a solid year of work to
support subinterpreters in NumPy.  He also <a href="/ml/python-dev/df0782e956eb784ac40e424fedc33059275507a6.camel@sipsolutions.net/">said</a> that
the proposal to raise an exception when subinterpreters import extensions
that are not subinterpreter-ready is helpful, though it likely will still lead to
bugs being filed against the extensions.  The PEP proposes to raise
<tt>ImportError</tt> for any extension that does not support <a href="https://www.python.org/dev/peps/pep-0489/">PEP 489</a>
("<q>Multi-phase extension module initialization</q>"); multi-phase
initialization eliminates the problems with global state variables for the
extensions by moving them into their own module-specific dictionary object.
</p>

<p>
Both Smith and Berg are skeptical of the existing C-level subinterpreter
support. Berg said: "<q>I believe
you must consider subinterpreters basically a non-feature at this time.
It has neither users nor reasonable ecosystem support</q>", while Smith
said that he might write a PEP to propose that subinterpreters be
completely eliminated from Python.  Snow <a href="/ml/python-dev/CALFfu7DkjwmdG=n1DtvFQzNshYqwvCPnuhHkdajasLKakn_0OA@mail.gmail.com/">replied</a>
to Berg that there are existing users, however:
</p><div class="BigQuote">
FWIW, at this point it would be hard to justify removing the existing
public subinterpreters C-API.  There are several large public projects
using it and likely many more private ones we do not know about.
<p>
That's not to say that alone justifies exposing the C-API, of course. :)
</p></div>
<p></p>

<h4>Benefits?</h4>

<p>
Beyond the concerns about extensions, though, Smith is not convinced of the
benefits for concurrency that could eventually come from subinterpreter
support.  PEP 554 is careful not to directly connect the
<tt>interpreters</tt> module with the eventual plan to stop sharing the GIL
between subinterpreters, though it is clearly the eventual goal for some.
Smith is skeptical of that plan as well:
</p><div class="BigQuote">
In talks and informal conversations, you paint a beautiful picture of
all the wonderful things subinterpreters will do. Lots of people are
excited by these wonderful things. I tried really hard to be excited
too. (In fact I spent a few weeks trying to work out a
subinterpreter-style proposal myself way back before you started
working on this!) But the problem is, whenever I look more closely at
the exciting benefits, I end up convincing myself that they're a
mirage, and either they don't work at all (e.g. quickly sharing
arbitrary objects between interpreters), or else end up being
effectively a more complex, fragile version of things that already
exist.
</div>
<p></p>

<p>
Berg concurred to a certain extent.  He said that there is a need for a
wider vision, beyond the PEP's smaller goals, to explain what the plans are
for subinterpreters so that a fuller picture can be considered.  Snow
agreed that there was a need for better documentation, an informational
PEP or other justification document, though that has not appeared as yet.
Ultimately, the decision on the PEP rests with  Antoine Pitrou, who is
the delegate for the PEP.  He is generally <a href="/ml/python-dev/20200418190247.1925b608@fsol/">favorably inclined</a>
toward it:
</p><div class="BigQuote">
Mostly, I hope that by making the
subinterpreters functionality available to pure Python programmers
(while it was formally an advanced and arcane part of the C API), we
will spur of bunch of interesting third-party experimentations,
including possibilities that we on python-dev have not thought about.
</div>
<p></p>

<p>
He had some concrete suggestions on things to improve in the API and
suggested that the feature be added provisionally (effectively option two
in Snow's original message).  He also explicitly solicited more feedback.
Mark Shannon reviewed the PEP and <a href="/ml/python-dev/19580613-9375-a8a6-67f7-d79e4f766177@hotpy.org/">said</a>
that he was in favor of the idea, but that it did not make sense to add the
module to the standard library without showing that it would be beneficial
for parallelism:
</p><div class="BigQuote">
My main objection is that without per-[subinterpreter] GILs (SILs?) PEP 554
provides no value over threading or multi-processing.
Multi-processing provides true parallelism and threads provide shared
memory concurrency.
<p>
If per-[subinterpreter] GILs are possible then, and only then,
sub-interpreters will provide true parallelism and (limited) shared memory
concurrency.
</p><p>
The problem is that we don't know whether we can implement
per-[subinterpreter] GILs without too large a negative performance impact.
I think we can, but we can't say so for certain.
</p></div>
<p></p>

<p>
Snow <a href="/ml/python-dev/CALFfu7AA-4J7Y72T4s-E81cp-rb4Q0LhK_0am0qS3S3Pa66YoQ@mail.gmail.com/">disagreed</a>,
not surprisingly, but Shannon put together a <a href="https://gist.github.com/markshannon/79cace3656b40e21b7021504daee950c">table</a>
comparing different existing approaches to concurrency in Python with PEP
554 and an "ideal" <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">communicating
sequential processes</a> (CSP) model. Go's concurrency model is roughly
based around CSP; adding it to Python has also <a href="https://github.com/futurecore/python-csp">been tried</a> along the
way.  Shannon <a href="/ml/python-dev/6354f883-61fa-8121-7f51-c6d36abd835f@hotpy.org/">said</a>: 
</p><div class="BigQuote">
 There are lot of question
marks in the PEP 544 column. The PEP needs to address those.
<p>
As it stands, multiprocessing a better fit for CSP than PEP 554.
</p><p>
IMO, sub-interpreters only become a useful option for concurrency if they
allow true parallelism and are not much more expensive than threads.
</p></div>
<p></p>

<p>
Snow <a href="/ml/python-dev/CALFfu7A+stkJ3_vsfA2b+Fgu68W+wFLp84g+at-s_3p=+-f+LQ@mail.gmail.com/">sees</a>
concurrency as something of a side issue, but he is thinking of taking up
the suggestion by Berg and others to more fully document the complete plan:
</p><div class="BigQuote">
I really want to keep discussion focused on the proposed
API in the PEP.  Honestly I'm considering taking up the recommendation
to add a new PEP about making subinterpreters official.  I never meant
for that to be more than a minor point for PEP 554.
</div>
<p></p>

<p>
There was plenty of other discussion, but Snow eventually <a href="/ml/python-dev/CALFfu7C=Onsug+jXcxeEMU_jCxS73H8y4ZMPfqS-p6sW9F4MxQ@mail.gmail.com/">deferred</a>
the PEP until the&nbsp;3.10 time frame:
</p><div class="BigQuote">
FYI, after consulting with the steering council I've decided to change
the target release to 3.10, when we expect to have per-interpreter GIL
landed.  That will help maximize the impact of the module and avoid
any confusion.  I'm undecided on releasing a 3.9-only module on PyPI.
If I do it will only be for folks to try it out early and I probably
won't advertise it much.
</div>
<p></p>

<p>
It is an interesting feature and one that numerous core developers think
could really help the performance of Python programs on multiple cores.
But, without the GIL changes, it is difficult to know for sure whether it
will be a substantial win.  As Smith <a href="/ml/python-dev/CAPJVwB=-9XsNtxFqawkLHNfPH59yvAV6KEqEEEYzKq9JzYY9Dg@mail.gmail.com/">put
it</a>: "<q>[...]  the new concurrency model in PEP 554 has never actually
been used, and it isn't even clear whether it's useful at all.
Designing useful concurrency models is *stupidly* hard.</q>"  We will
have to wait to see if subinterpreters can clear that hurdle.
</p><br clear="all"><table class="IndexEntries">
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="/Archives/PythonIndex/">Python</a></td><td><a href="/Archives/PythonIndex/#Python_Enhancement_Proposals_PEP-PEP_554">Python Enhancement Proposals (PEP)/PEP 554</a></td></tr>
            <tr><td><a href="/Archives/PythonIndex/">Python</a></td><td><a href="/Archives/PythonIndex/#Subinterpreters">Subinterpreters</a></td></tr>
            </tbody></table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/820424/">
            <input type="submit" name="login" value="Log in"> to post comments
            <p>
        
</p></form></div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor820453"></a>
    </p><details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 13, 2020 23:26 UTC (Wed)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/820453/">Link</a>] 
      </p></summary>
     <p>From the very bottom of the PEP, it sounds like all the necessary changes to the CPython API/implementation have already been merged? (Or is it just that the work has been done in a fork but not yet merged?) If the CPython changes can be merged by themselves, does the "interpreters" module need to be part of the standard library, or can it be a CPython extension module with the same functionality?</p>
<p>That seems like it would help with the concern of breaking other extension modules. "NumPy doesn't work with this other random extension module I found on PyPI" is much easier for the developers to dismiss (and much less likely to be filed, at all) than "NumPy doesn't work with this thing in Python 3.9 core."</p>
<p>(Also given the <a href="https://www.python.org/dev/peps/pep-0594/">"removing dead batteries" PEP</a> and the points it makes about maintenance burden, implicit endorsement of things in the standard library, etc., it seems worth keeping new batteries <i>out</i> until they're fully charged.)</p>
     
  <div class="CommentReplyButton">
    
      <input type="submit" value="Reply to this comment">
    
  </div>

     <p>
     
    </p></details>
<a name="CommAnchor820454"></a>
    <details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 0:40 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/820454/">Link</a>] (2 responses)
      </p></summary>
     <div class="FormattedComment">
I am rather skeptical of this idea. Quoting Nick Coghlan from the "Rationale" section of PEP 554:<br>
<p>
<font class="QuotedText">&gt; [I] expect that communicating between subinterpreters is going</font><br>
<font class="QuotedText">&gt; to end up looking an awful lot like communicating between</font><br>
<font class="QuotedText">&gt; subprocesses via shared memory.</font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt; The trade-off between the two models will then be that one still</font><br>
<font class="QuotedText">&gt; just looks like a single process from the point of view of the</font><br>
<font class="QuotedText">&gt; outside world, and hence doesn't place any extra demands on the</font><br>
<font class="QuotedText">&gt; underlying OS beyond those required to run CPython with a single</font><br>
<font class="QuotedText">&gt; interpreter, while the other gives much stricter isolation</font><br>
<font class="QuotedText">&gt; (including isolating C globals in extension modules), but also</font><br>
<font class="QuotedText">&gt; demands much more from the OS when it comes to its IPC</font><br>
<font class="QuotedText">&gt; capabilities.</font><br>
</p><p>
I must admit that this comes across as a bit abstruse to me. All modern operating systems have something which resembles a pipe or socket, and for the most part, they also have a reasonable way of sharing memory between processes (admittedly, the Windows way is a bit odd, but it certainly exists). Perhaps Nick was thinking of some other form of IPC, but if so, I cannot divine it from what he has written. A great deal of IPC-related complexity has already been implemented in the multiprocessing module (it has a number of primitives for copying objects across the process boundary).<br>
</p><p>
I find it unfortunate that so many C extensions have tacitly assumed there can be only one Python interpreter in the whole process, but it appears that this assumption is endemic to large swaths of the community. It seems imprudent to provide a stdlib facility which will break popular extensions such as NumPy, and I suspect that this will block the PEP's adoption in the short term.<br>
</p></div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820454/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    <a name="CommAnchor820670"></a>
    </p><details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 15, 2020 20:37 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/820670/">Link</a>] (1 responses)
      </p></summary>
     <div class="FormattedComment">
<font class="QuotedText">&gt; I find it unfortunate that so many C extensions have tacitly assumed there can be only one Python interpreter in the whole process, but it appears that this assumption is endemic to large swaths of the community. It seems imprudent to provide a stdlib facility which will break popular extensions such as NumPy, and I suspect that this will block the PEP's adoption in the short term.</font><br>
<p>
If the CPython API weren't designed around there being only one interpreter, maybe this could all have been avoided. I still don't get why an extra pyctx parameter wasn't added to every C API at some point (Python3 seems like it would have been a perfect time). The existing ones can become macros (with trampolines for ABI compat if that mattered) that pass the existing global context around. Wean yourself off that and now CPython isn't encouraging static globals anymore.<br>
</p><p>
Granted, I'm sure it's a lot of work and Python already burnt too many bridges for such an API break to happen again and be accepted.<br>
</p><p>
But I'd not be so quick to blame the extension developers when the core doesn't have it's act together either.<br>
</p></div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820670/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    <a name="CommAnchor820729"></a>
    </p><details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 17, 2020 6:20 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/820729/">Link</a>] 
      </p></summary>
     <div class="FormattedComment">
My apologies, it was not my intent to blame either the extensions or the core. My point was that, even though what you describe would be a superior design, that's not the API we have to live with.<br>
</div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820729/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    </p></details>
</details>
</details>
<a name="CommAnchor820460"></a>
    <details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 5:04 UTC (Thu)
                               by <b>Rudd-O</b> (guest, #61155)
                              [<a href="/Articles/820460/">Link</a>] (6 responses)
      </p></summary>
     <div class="FormattedComment">
Makes me sad.  This was the best opportunity to steal most of Go's best feature — in-process CSP/channels — with a very simple API.<br>
<p>
Can the same thing be done with multiprocessing or threading?  No, not really, as the semantics of those mechanisms aren't quite right.<br>
</p><p>
Tragic torpedoing of a good idea.<br>
</p></div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820460/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    <a name="CommAnchor820462"></a>
    </p><details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 5:46 UTC (Thu)
                               by <b>Cyberax</b> (<b>✭ supporter ✭</b>, #52523)
                              [<a href="/Articles/820462/">Link</a>] (4 responses)
      </p></summary>
     <div class="FormattedComment">
Uhh... What? Go's channels can be trivially expressed in languages with threading support, like C++ or Java. There's nothing at all special about Go channels, except that they are built-in into the language.<br>
</div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820462/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    <a name="CommAnchor820479"></a>
    </p><details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 13:01 UTC (Thu)
                               by <b>enchantner</b> (guest, #138900)
                              [<a href="/Articles/820479/">Link</a>] (2 responses)
      </p></summary>
     <div class="FormattedComment">
Well, it depends on how you implement them. True, the simplest implementation is just a mutex, but in a dynamic Python world with GC and refcounts, especially with multiprocessing, it also would require some "pass-the-ownership" semantics to work properly, like std::move in C++.<br>
</div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820479/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    <a name="CommAnchor820538"></a>
    </p><details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 16:44 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/820538/">Link</a>] (1 responses)
      </p></summary>
     <div class="FormattedComment">
Yes, and they already did that hard work for you in the stdlib: <a href="https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes">https://docs.python.org/3/library/multiprocessing.html#ex...</a><br>
</div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820538/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    <a name="CommAnchor820573"></a>
    </p><details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 19:37 UTC (Thu)
                               by <b>enchantner</b> (guest, #138900)
                              [<a href="/Articles/820573/">Link</a>] 
      </p></summary>
     <div class="FormattedComment">
I wish all that had performance which is somewhat comparable with Go or at least GNU Parallel. Basically, forking and dealing with pipes is just a bunch of syscalls. I get why these guys did what they did, but I think it could be better.<br>
</div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820573/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    </p></details>
</details>
</details>
<a name="CommAnchor820594"></a>
    <details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Pygolang</h3>
      <p class="CommentPoster"> Posted May 15, 2020 8:35 UTC (Fri)
                               by <b>kirr</b> (guest, #14329)
                              [<a href="/Articles/820594/">Link</a>] 
      </p></summary>
     <p>&gt; Uhh... What? Go's channels can be trivially expressed ...</p>
<p>For the reference:</p>
<p><a href="https://pypi.org/project/pygolang/">https://pypi.org/project/pygolang/</a></p>
<p>and in particular GIL-avoidance mode:</p>
<p><a href="https://pypi.org/project/pygolang/#cython-nogil-api">https://pypi.org/project/pygolang/#cython-nogil-api</a></p>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820594/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    </p></details>
</details>
<a name="CommAnchor820579"></a>
    <details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 21:06 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/820579/">Link</a>] 
      </p></summary>
     <div class="FormattedComment">
If you want Go-style *semantics* (shared-everything + channels to pass objects around), then Python already has that, though threads or async libraries.<br>
<p>
If you want Go-style multi-core efficiency, though, without the GIL messing things up... then that's harder. CPython is stuck with using the GIL to protect access to Python objects. Therefore, if you want each subinterpreter to have its own GIL, then that means you can never pass Python objects between subinterpreters.<br>
</p><p>
So the reality is that subinterpreters are like subprocesses: each new subinterpreter has to re-load all modules from scratch, passing objects between subinterpreters requires pickling/sending bytes/unpickling, etc. PEP 543 uses the words "CSP" and "channel" a lot, but this was never going to look like Go.<br>
</p></div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820579/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    </p></details>
</details>
<a name="CommAnchor820461"></a>
    <details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 5:09 UTC (Thu)
                               by <b>eric.saint.etienne</b> (guest, #123009)
                              [<a href="/Articles/820461/">Link</a>] (2 responses)
      </p></summary>
     <div class="FormattedComment">
Changing the standard library to circumvent the limitation of one interpreter, CPython, even if it's the most used as of today, seems wrong.<br>
Subinterpreters wouldn't help with performances on interpreters with no GIL like Jython or IronPython and possibly Python for GraalVM.<br>
</div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820461/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    <a name="CommAnchor820463"></a>
    </p><details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 5:50 UTC (Thu)
                               by <b>Cyberax</b> (<b>✭ supporter ✭</b>, #52523)
                              [<a href="/Articles/820463/">Link</a>] (1 responses)
      </p></summary>
     <div class="FormattedComment">
Realistically, IronPython or Jython are not even footnotes right now. Heck, Jython doesn't even support Py3.<br>
<p>
There are exactly two real-world implementations of Python: CPython and PyPy. Both will have to be modified heavily to support GIL-less world, with subinterpreters being a somewhat lesser evil.<br>
</p></div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820463/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    <a name="CommAnchor820494"></a>
    </p><details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 12:38 UTC (Thu)
                               by <b>Conan_Kudo</b> (subscriber, #103240)
                              [<a href="/Articles/820494/">Link</a>] 
      </p></summary>
     There is also <a href="https://www.graalvm.org/docs/reference-manual/languages/python/">an experimental GraalVM implementation of Python 3.7</a>, but yeah, the landscape of Python implementations is kind of barren with Python 3 at the moment. 
     
  <div class="CommentReplyButton">
    <form action="/Articles/820494/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    </p></details>
</details>
</details>
<a name="CommAnchor820470"></a>
    <details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 8:42 UTC (Thu)
                               by <b>flussence</b> (subscriber, #85566)
                              [<a href="/Articles/820470/">Link</a>] (2 responses)
      </p></summary>
     <div class="FormattedComment">
Smells like Perl 5.8.0's interpreter threads. Or Java 1.1's green threads? “Concurrent” Javascript via iframes in Internet Explorer 6? Perl 6's threading model fifteen years ago?<br>
<p>
I'm flabbergasted that this is all Python can muster in 2020. Cooperative multitasking based on string eval.<br>
</p></div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820470/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    <a name="CommAnchor820476"></a>
    </p><details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 8:58 UTC (Thu)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/820476/">Link</a>] 
      </p></summary>
     <div class="FormattedComment">
<font class="QuotedText">&gt; based on string eval</font><br>
Not even pickle'd for efficient serialisation between subinterps.<br>
<p>
I've not read the proposal, but it being absent from this article suggests there's no aysnc-yield pairing either for saying 'evaluate until this other component is ready to progress global tasking state'. That's something that V8 and ES-16 made easy to manage with (resolve, reject) promises.<br>
</p><p>
K3n.<br>
</p></div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820476/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    </p></details>
<a name="CommAnchor820483"></a>
    <details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 10:46 UTC (Thu)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/820483/">Link</a>] 
      </p></summary>
     <p>
Tcl offered a language-level subinterpreter feature quite similar to this (including a facility to use subinterpreters that had all their dangerous commands removed, to execute untrusted Tcl code) in the late 1990s/very early 2000s. At the time nobody else had anything of the sort and it was pretty nifty.
</p>
     
  <div class="CommentReplyButton">
    <form action="/Articles/820483/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    </p></details>
</details>
<a name="CommAnchor820496"></a>
    <details class="CommentBox" open="">
      <summary><h3 class="CommentTitle">Subinterpreters for Python</h3>
      <p class="CommentPoster"> Posted May 14, 2020 12:39 UTC (Thu)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/820496/">Link</a>] 
      </p></summary>
     <div class="FormattedComment">
<font class="QuotedText">&gt; prevents prevents multiple</font><br>
<p>
This typo is even self-explanatory! :)<br>
</p><p>
(Sorry, couldn't resist)<br>
</p></div>

     
  <div class="CommentReplyButton">
    <form action="/Articles/820496/comment" method="post">
      <input type="submit" value="Reply to this comment">
    </form>
  </div>

     <p>
     
    </p></details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <p>
            <span class="ReallySmall">
            Copyright © 2020, Eklektix, Inc.<br>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </p></center>
            
            
</body></html>
```
